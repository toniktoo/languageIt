//Python: Настройка окружения
const course = {
  Введение: [{ theory: ``, tests: {}, tasks: {} }],
  Введение: [
    {
      theory: `
        Хекслет построен таким образом, что все задания выполняются прямо в браузере (не считая проектов, в которых, как раз отрабатываются навыки реальной работы в настоящем окружении). Такой подход позволяет сосредоточиться на самой задаче, но, к сожалению, рождает ложное ощущение понимания происходящего. Изучение программирования во многом связано с настройкой среды, и для немалого числа людей процесс установки и конфигурирования сложнее, чем написание кода. Чем быстрее вы начнёте возиться с кодом у себя на компьютере, тем быстрее пойдёт прогресс, и вы сможете писать реальные приложения, решать тестовые задания! Кстати, о заданиях. На Хекслете, мы поддерживаем список тестовых заданий от разных компаний. Рекомендую пользоваться им, как ориентиром. Идеально, если в процессе обучения вы сможете реализовать хотя бы одно-два у себя на github. Во-первых, это придаст уверенности, и вы увидите, что уже кое-что можете, во-вторых, работодатели смогут оценить ваш гитхаб-аккаунт и посмотреть на код.

        В этом курсе мы не только установим и настроим Python, но также познакомимся с пакетным менеджером poetry, научимся подключать сторонние библиотеки и выкладывать свой собственный код в публичный доступ. В дальнейшем, все что даёт курс, отрабатывается на первом проекте профессии. Обращаю ваше внимание на то, что в курсе мы ориентируемся на POSIX-совместимые операционные системы. К таким, например, относятся Linux и macOS, но не относится Windows. Если ваша основная система Windows, то рекомендую ознакомиться с нашими руководствами, описывающими способы подготовки к работе: https://guides.hexlet.io/.
        
        Перед тем, как начать, убедитесь в следующих вещах:
        
        Вы используете правильную операционную систему (например, Ubuntu, macOS) или настроили Windows согласно одной из инструкций по ссылке выше
        Вы знаете, как запустить терминал, и можете выполнять команды в нём (если нет, то смотрите наш курс)
        Вы установили редактор кода, например, VS Code
        Вы прошли наш курс Системы контроля версий (GIT), либо уже имеете опыт работы с распределёнными системами контроля версий
        Необязательно, но крайне желательно:
        
        Посмотреть видео про утилиту make
        Кроме того, мы поддерживаем репозиторий python-package — так называемую заготовку, содержащую базовую структуру нового проекта на Python. Вы всегда можете подглядывать в него и делать по аналогии.
        
        Настройка окружения — процесс, который часто вводит в ступор. Команды выдают ошибки, и понять их природу бывает сложно даже опытным разработчикам. Связано это с тем, что абсолютно у каждого человека своя собственная уникальная комбинация оборудования, программного обеспечения и настроек. Даже имя пользователя нередко влияет на то, как все работает (особенно в Windows, особенно если имя на русском языке). В случае проблем с настройкой, рекомендуем обращаться в наш чат https://slack-ru.hexlet.io (канал #python), где опытные пользователи любят помогать новичкам.
        
        Редактирование файлов
        В процессе работы вам понадобится редактировать файлы из терминала. В мире администрирования и программирования принято делать это, используя VIM. Не забудьте прочитать наш гайд, посвящённый VIM, чтобы научиться использовать его базовые возможности.`,
      tests: {},
      tasks: {},
    },
  ],
  Установка_Python: [
    {
      theory: `
        Начнём с установки Python. Python можно скачать и установить с официального сайта Python, но лучше выполнить эту процедуру через пакетные менеджеры. Откройте терминал и выполните команду, подходящую к вашей операционной системе:

        Ubuntu
        $ sudo apt update
        $ sudo apt install python3
        macOS
        # https://brew.sh/index_ru.html
        $ brew install python
        Windows
        # https://chocolatey.org/
        $ choco install python
        Если установка прошла без ошибок, то самое время убедиться в том, что Python работает. Заметьте, что "установилось" и "работает" — не одно и тоже.
        
        Наберите в терминале python3 --version. Вывод должен быть примерно такой:
        
        
        Убедитесь в том, что установленная версия не ниже 3.6.
        
        Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях, когда интерактивного интерпретатора недостаточно, код можно и нужно запускать в виде файлов. Для этого нужно создать файл с любым именем и расширением py, например, main.py, а затем запустить:
        
        
        Обратите внимание, что запускать код нужно из той же директории, в которой лежит файл main.py, либо указывать путь до файла.
        
        pyenv
        Совсем другой способ установки Python — утилита pyenv (для пользователей Windows нужна особая версия утилиты - pyenv-win). Кроме установки любых версий Python, эта утилита позволяет удобно переключаться между версиями. Такое может быть нужно когда вы одновременно работаете над несколькими проектами, требующими разные версии Python.`,
      tests: {},
      tasks: {},
    },
  ],
  Работа_с_REPL: [
    {
      theory: `
        REPL
        Python поставляется со встроенным REPL. REPL – это программа, которая работает как командная оболочка (программу REPL ещё называют интерактивным интерпретатором Python), предназначенная для ввода и выполнения кода на языке Python. Акроним REPL расшифровывается так:
        
        Read — прочитать ввод от пользователя,
        Eval — выполнить введённый код,
        Print — распечатать на экран результат,
        Loop — снова войти в режим ожидания.
        Для запуска REPL достаточно набрать python3:
        
        
        Теперь можно выполнять код на Python и сразу же смотреть на результат его выполнения. Наберите любой корректный код на Python, например такой:
        
        
        REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из REPL нужно вместо ввода кода нажать Ctrl + D.
        
        Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. Пример работы с REPL:
        
        
        Встроенная документация
        Язык Python прямо на уровне синтаксиса поддерживает дополнение кода документацией. Основным средством документирования являются так называемые "строки документации" ("docstrings"). Документированная функция выглядит так:
        
        def add(x, y):
            """Add one argument to another."""
            return x + y
        Из таких docstrings генерируется online-документация. А ещё эта документация доступна для просмотра прямо в REPL! Для просмотра документации служит функция help. Давайте объявим функцию add в REPL, попробуем её вызвать, а затем посмотрим описание нашей функции и нескольких встроенных:
        
        
        Даже просто быстро узнать, что делает та или иная функция — очень полезно. Но функция help может работать и в интерактивном режиме: если её вызвать без аргументов (help()), то будет показана страница приветствия и приглашение в строке ввода изменится на help>. Страница приглашения показывает, какие команды можно вводить, а также упоминает, что для выхода из режима справки нужно дать команду quit (нажатие Ctrl+D вместо ввода команды тоже сработает). Новичкам может быть полезна команда topics, выводящая список тем, по которым можно почитать статьи прямо в этом же режиме справки REPL'а. Войдём же в режим справки, выведем список тем, а затем откроем статью, которая рассказывает о доступных в языке Python операторах:
        
        
        REPL и примеры кода в источниках.
        REPL в Python-мире настолько широко используется, что в самых разных источниках — статьях, книгах, документации к библиотекам — можно встретить примеры, изображающие кусочек "диалога" программиста и REPL. Выглядит это примерно так:
        
        >>> 1 + 2
        3
        >>> len("Thomas")
        6
        >>> "Hello" + '\n' + "World!"
        'Hello\nWorld!'
        >>> print("Hello" + '\n' + "World!")
        Hello
        World!
        Здесь строчки, начинающиеся на >>> (эти символы называются "приглашением" ("prompt")) — это код, введённый программистом. А следующий за "вводом" текст до следующей строчки с приглашением, представляет собой результат выполнения введённого кода. Если вы решите попробовать указанный в таком виде пример самостоятельно, не вводите само приглашение, вводите только сам код, следующий за символами >>>. И строки вывода тоже вводить не нужно — тут уж интерпретатор сам справится!
        
        Привыкайте к этому формату публикации примеров, в наших курсах он тоже будет использоваться широко!
        
        Каноническое представление и вывод на печать
        Заметьте, что при вводе строки, в выводе интерпретатора оная отображается с кавычками и со спецсимволами. Числа выводятся, как числа. То же самое касается вывода любых других значений: большинство значений выводится в виде "канонического строкового представления" ("canonical string representation"). Представленные таким образом значения, как правило, можно скопировать в строку приглашения и выполнить опять, т.е. каноническое представление обычно является правильным кодом на Python.
        
        Кстати, самостоятельно получить каноническое представление произвольного значения можно с помощью функции repr. Примеры:
        
        >>> repr(42)
        '42'
        >>> repr("foo")
        '"foo"'
        >>> repr(None)
        'None'
        А вот результат вызова функции print не содержит кавычек, и спецсимволы, вроде символа переноса строки, не отображаются (но эффект на вывод оказывают). Так происходит, как вы могли догадаться, потому, что мы видим результат вывода строки на печать.
        
        REPL и None
        Ещё вам стоит знать о том, как REPL отображает возврат из функции значения None. Дело в том, что никак! Это сделано специально: любая функция, которая не возвращает результат явно, считается функцией, возвращающей None. И чтобы не "мозолить глаза" программисту бесконечными None в выводе REPL, авторами интерпретатора было решено подавлять вывод этого значения. Именно поэтому в примере выше REPL мы не увидели, что функция print на самом деле вернула None! Но мы всё же можем увидеть в REPL None, если обернём вызов print... в ещё один вызов print:
        
        >>> print(42)
        42
        >>> print(print(42))
        42
        None
        Вот и оно, значение None! Мы видим это значение потому, что второй print получает None на вход и приводит к строке, а уже строку — печатает.
        
        Если вы вдруг столкнётесь с ситуацией, когда ваша функция в REPL вызывается, но "ничего не возвращается" — не паникуйте! Возможно ваша функция всего лишь возвращает None (скажем, потому, что вы забыли сделать return)!
        
        Ввод многострочного кода
        В Python REPL можно вводить и многострочный код, а ведь не каждый REPL такое позволяет! И пусть отредактировать уже введённые строчки не получится, но, к примеру, небольшие функции вводить вполне удобно. Когда вы вводите строчку, которая по смыслу ещё не завершилась, то REPL меняет приглашение на ... и ожидает ввода новой строчки в дополнение к уже введённой. Так можно ввести целое определение функции вместе с docstring и логикой. Окончанием ввода всего многострочного кода служит пустая строчка (поэтому в коде не получится использовать пустые строчки). В источниках примеры с многострочным кодом будут выглядеть так:
        
        >>> def is_positive(x):
        ...     """Return True if argument is positive."""
        ...     if x <= 0:
        ...          return False
        ...     return True
        ...
        >>> is_positive(42)
        True
        REPL — удобный калькулятор
        Python REPL удобно использовать даже в роли обычного калькулятора, но типичный калькулятор обладает важным свойством — помнит промежуточный результат. Конечно, мы можем использовать для хранения промежуточных результатов переменную:
        
        >>> result = 42 * 7
        >>> result = result - 1
        >>> result = result // 2
        >>> result
        146
        Обратите внимание, присваивание не приводит к выводу каких-либо значений. Тогда как любая функция возвращает что-нибудь, пусть даже и None, встроенные инструкции (statements) никогда не возвращают значения (и поэтому, в частности, не могут быть частью выражений).
        
        Использование переменных полезно, если промежуточные результаты нам понадобятся позже. Но если результат нужен только в следующем выражении, то можно использовать специальную переменную _, которая всегда хранит результат выполнения предыдущей команды:
        
        >>> 42 * 7
        294
        >>> _ - 1
        293
        >>> _ // 2
        146
        >>> _
        146
        Вот теперь уже больше похоже на работу привычного калькулятора: промежуточные результаты и сохраняются и выводятся на экран после каждого действия!
        
        Более того, переменная _ сохраняет последний успешно полученный результат. Если при выполнении какой-то строчки кода произошла ошибка, то предыдущий результат не будет потерян! Также результат не теряется, если вы вводите инструкции (statements). Это удобно, к примеру, когда вы хотите сохранить текущее значение в переменную. Вот пример, который демонстрирует устойчивость к ошибкам и сохранение результата во время выполнения инструкций.
        
        >>> 42
        42
        >>> _ // 0
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        ZeroDivisionError: integer division or modulo by zero
        >>> _ // 6
        7
        >>> a = _
        >>> _ + 20
        27
        >>> a
        7
        Важно: специальная переменная _ доступна только в REPL, в коде программ такая переменная может быть объявлена, но работать она будет, как любая другая. Помните об этом, когда будете переносить код из REPL в модули.
        
        Самостоятельная работа
        Вычислите в репле значение выражения sqrt(256) + 100 и выведите его на экран, используя функцию print. Фукнция sqrt определена в модуле math, так что её нужно будет предварительно импортировать.
        Запишите вычисление и вывод выражения в файл и запустите этот файл (с помощью python3).`,
      tests: {},
      tasks: {},
    },
  ],
  Подробнее_о_Python: [
    {
      theory: `
        Что вообще такое язык программирования? За этим понятием скрываются две связанных, но независимых темы.

        Язык программирования
        С одной стороны, языком программирования называют правила (синтаксические и семантические), по которым записывается и работает исходный код. В отличие от естественных языков, эти правила достаточно строги. Любая мельчайшая ошибка и код либо не запустится, либо запустится, но не заработает, как ожидается. Например, в Python нельзя написать my name = 5 (с пробелом в имени переменной). Эти правила существуют не только в книгах, но и в головах конкретных программистов и разработчиков языка. Часто весь свод правил, называемый спецификацией, существует в виде отдельного специального документа.
        
        С другой стороны, языком программирования называют программу, которая непосредственно запускает (или компилирует) наш код. В предыдущем уроке мы как раз установили такую. Обычно её называют средой выполнения, иногда "рантаймом" ("runtime"), если речь идёт про интерпретацию. Среда выполнения — конкретное воплощение спецификации, по-другому называемое реализацией (или implementation). Реализаций конкретного языка может существовать несколько, но часто существует так называемая эталонная реализация (или reference implementation), на которую могут равняться другие. Различные реализации могут разрабатываться разными людьми и компаниями.
        
        У Python нет выделенной спецификации, но есть эталонная реализация, называемая CPython (интерпретатор Python, реализованный на языке C). Если вы слышите, что кто-то говорит Python, то скорее всего имеется в виду именно эталонная реализация. Прочие же реализации обычно имеют свои названия. Например, реализация языка, предназначенная для запуска программ на платформе .NET, называется IronPython.
        
        Python
        Python — интерпретируемый язык программирования с сильной динамической типизацией. Разберём эти слова по отдельности.
        
        Интерпретируемый
        У Python отсутствует стадия компиляции в машинный код, которая присутствует, скажем, у языков C, Rust, Go. Программа исполняется интерпретатором шаг за шагом, а не запускается напрямую на процессоре компьютера. Поэтому для запуска программы на Python всегда нужна среда исполнения (интерпретатор) — только она может выполнять Python-программы.
        
        Строго говоря, у Python есть фаза компиляции, во время которой код из текста преобразуется в специальное представление, называемое "байткод" ("bytecode"), а затем уже этот байткод передаётся в интерпретатор. Но внешне Python ведёт себя именно как интерпретируемый язык программирования: интерпретатор при запуске вашей программы загружает из файлов её (программы) исходный код, преобразует для удобства в байткод (при этом проверяются ошибки синтаксиса), а дальше начинает исполнять по шагам.
        
        Динамическая типизация
        В динамически типизированных языках проверка типов, доступности функций и переменных производится интерпретатором во время выполнения кода. Поэтому, если мы случайно ошиблись и, например, вызвали несуществующую функцию, то ошибка всплывёт только во время вызова этой функции! В статически же типизированных языках подобные ошибки отслеживаются на этапе анализа исходного текста без запуска кода на выполнение (слово "статический" как раз означает, что программа не выполняется). Обычно статическими проверками занимаются компиляторы, но существуют и выделенные инструменты статической проверки кода, так называемые статические анализаторы кода. Для некоторых языков с динамической типизацией такие анализаторы тоже существуют, но отслеживают значительно меньшее число ошибок.
        
        Сильная типизация
        Сильная типизация означает то, что Python старается не приводить типы (преобразовывать значения одних типов в значения других) автоматически. Это означает, что Python не даст сложить число со строкой: при попытке сделать что-то подобное мы получим ошибку. Далеко не все языки с динамической типизацией столь педантичны в силу различных причин. Но Python в этом вопросе принципиален и требует, чтобы любые преобразования типов были явными (т.е. программист использовал в каждом конкретном случае соответствующие функции-преобразователи).
        
        Дополнительные материалы
        Что такое компиляция
        Что такое интерпретация`,
      tests: {},
      tasks: {},
    },
  ],
  Пакеты_и_индексы: [
    {
      theory: `
        В какой-то момент разработчик понимает, что код, который он написал, может быть полезен другим. Это может быть библиотека полезных функций или готовая программа, но в любом случае автор оной обычно хочет, чтобы его творение было удобно и просто использовать. Так вот, питонисты делятся между собой кодом с помощью… пакетов!

        Опять пакеты
        В рамках курса по основам Python уже упоминались пакеты (packages). Тогда пакеты описывались, как наборы модулей и вложенных пакетов. Но это не единственное значение слова "пакет" в Python-мире.
        
        В более широком смысле пакет — это некая единица обмена кодом между разработчиками. Python-пакет содержит и исходный код (как раз в виде пакета в узком смысле, поэтому и название общее), и так называемые метаданные — дополнительную информацию о пакете. Метаданные описывают
        
        предназначение пакета
        версию пакета
        совместимость с разными версиями Python
        лицензию (software license), под которой распространяется пакет
        список и версии зависимостей пакета (об этом поговорим позже)
        и многое другое.
        
        Индекс
        Предположим, что мы имеем готовый пакет (а мы в итоге обязательно научимся их создавать), но как им поделиться с миром? Как правило, собранный пакет представляет собой обычный файл и в принципе его можно просто передать другому человеку — это даже сработает! А если вдруг окажется, что наш пакет требует каких-то других пакетов для своей работы? Вот тут-то и начнутся сложности — нужно будет приложить к нашему пакету дополнительные пакеты, которые могут потребовать ещё больше пакетов и т.д. и т.п.
        
        Для упрощения жизни как авторов пакетов, так и пользователей оных, существуют так называемые репозитории пакетов. Только в Python их принято называть индексами. Помимо предоставления пакетов, индексы также могут обладать интерфейсом для поиска пакетов, знакомства с их описанием — проще говоря, предоставляют интерфейс пользователя (обычно в виде web-сайта).
        
        Самый популярный индекс пакетов, это PyPI, Python Package Index. Чаще всего вы будете работать именно с ним. Но есть и другие индексы и большинство инструментов работы с пакетами могут работать с разными индексами. Отдельные индексы, к примеру, используются многими компаниями для размещения пакетов, которые не являются открытыми (open source).
        
        Ещё один полезный индекс — Test PyPI. Это специальный индекс пакетов, который принято использовать для обучения работы с системой пакетирования Python. Ведь не очень красиво выставлять на всеобщее обозрение сотни и даже тысячи учебных пакетов: они будут попадаться в поиске, "занимать" имена, которые могли бы иметь действительно полезные пакеты, другими словами — "замусоривать" основной индекс. Тестовый индекс работает точно так же, как основной PyPI – позволяет пакеты выкладывать и скачивать – но периодически удаляет все данные.
        
        Индексы vs GitHub, BitBucket и прочие хранилища кода
        В наши дни некоторые репозитории пакетов не хранят пакеты своими силами, а берут на себя только индексацию и управление метаданными пакетов, код же предлагается хранить на GitHub, BitBucket, GitLab, другими словами — в хранилищах исходного кода.
        
        Такой подход в целом работает для интерпретируемых языков, ведь для того, чтобы использовать код пакета, нужно всё равно иметь доступ к исходному коду. Но хранение кода на сторонних по отношению к источнику метаданных (индексу, в случае Python) обладает рядом недостатков.
        
        Во-первых, опубликованным кодом владеет только автор кода. Автор может даже удалить свой репозиторий, а информация о пакете в индексе сохранится. И те, кто начал использовать "сломанный" пакет, столкнутся с невозможностью сборки своих проектов.
        
        Во-вторых, ни GitHub, ни другие хранилища Git-репозиториев не могут гарантировать неизменность данных в репозитории при использовании одних только тегов и веток — а именно такой способ привязки состояния кода к информации в индексе и используется чаще всего — ведь любой обладатель доступа к репозиторию может "переписать историю". И даже если привязывать версии пакетов в индексе к hash-суммам коммитов в Git, то изменение в истории приведёт к первой проблеме — версия пакета будет ссылаться на несуществующий источник кода (при переписывании истории hash-суммы коммитов тоже поменяются).
        
        Обе озвученные причины приводят к тому, что ломается важное свойство системы пакетирования — воспроизводимость сборки. Воспроизводимость здесь означает, что любой проект, содержащий точное описание своих зависимостей, "соберётся" (в случае Python — запустится) в любой момент времени, даже если проект использует очень старые версии пакетов и интерпретатора!
        
        Централизованный индекс, самостоятельно хранящий все версии всех пакетов в неизменяемом виде, даёт значительно больше гарантий, что мы сможем собрать наш старый проект, когда бы мы этого ни захотели.
        
        Дополнительные материалы
        PyPI
        Test PyPI`,
      tests: {},
      tasks: {},
    },
  ],
  distutils_setuptools_pip: [
    {
      theory: `
        На прошлом уроке мы познакомились с пакетами и индексами, давайте же узнаем, как устанавливать пакеты из индекса! Для установки, обновления и удаления пакетов часто применяются так называемые пакетные менеджеры (или менеджеры пакетов). Один такой мы рассмотрим, но сначала немного поговорим о фундаменте системы пакетирования Python.

        distutils и setuptools
        В поставку Python входит distutils, пакет, отвечающий за создание дистрибутивов — архивов кода, которые могут быть распакованы в целевом окружении и установлены так, чтобы интерпретатор Python "увидел" распакованный код. При создании пакета программист создаёт в корневой директории будущего пакета файл setup.py в котором импортирует из модуля distutils функцию setup и вызывает её. Таким образом каждый пакет содержит в себе программу для управления собой!
        
        Подробнее о том, как работает distutils, можно почитать в официальной документации к пакету, а мы сразу двинемся дальше. Дело в том, что пакет distutils появился довольно давно и сейчас сам по себе не очень удобен в использовании. Гораздо чаще используется надстройка над distutils, пакет setuptools.
        
        Пакеты, собранные с помощью setuptools, уже умеют предоставлять metadata: описание, версию, и самое главное — собственные зависимости! Пакеты, которые не зависят ни от чего, кроме самого Python, настолько редки, что без setuptools — можно сказать, "жизни нет". Про этот пакет стоит знать и со временем нужно будет научиться его использовать (опять же, с помощью документации), но в рамках этого курса мы будем рассматривать более простой инструмент для создания пакетов и загрузки их в индекс — poetry, с которым мы познакомимся попозже.
        
        После того, как пакет создан и загружен в индекс, его можно скачать, распаковать во временную директорию, оттуда запустить python3 setup.py install и пакет установится. Но это слишком утомительный и непростой путь, есть способ лучше!
        
        pip
        Каким бы способом пакет ни был создан и загружен в индекс, его нужно скачивать и устанавливать, а по необходимости — и со всеми зависимостями. Сейчас этим в основном занимается специальная программа pip — The Python Package Installer.
        
        pip — большая и сложная программа. Обо всех возможностях вы, как всегда, сможете почитать в документации. Мы же рассмотрим только самую важную функцию pip — установку пакетов. В следующем уроке мы установим сам pip и с помощью него установим в окружение первый пакет!
        
        Дополнительные материалы
        distutils - Building and installing Python modules
        setuptools - Collection of enhancements to the Python distutils
        pip - The Python Package Installer`,
      tests: {},
      tasks: {},
    },
  ],
  Установка_pip: [
    {
      theory: `
        Установка pip
        Если вы используете macOS или Windows и устанавливали Python согласно нашим рекомендациям, то pip будет установлен вместе с интерпретатором. На Ubuntu его нужно поставить отдельно:
        
        $ sudo apt update
        $ sudo apt install python3-pip
        Запуск pip
        pip можно запускать непосредственно командой pip. Но лучше воспользоваться более длинной командой, которая гарантировано вызовет самую свежую установленную версию pip для нужной версии Python — в системе уже может быть установлен Py2 с соответствующей версией pip, как правило, довольно старой.
        
        Итак, вызываем pip:
        
        
        При показе своей версии pip также сообщает, куда установлен он сам и на какой версии Python он был запущен.
        
        Обратите внимание на структуру команды, которую мы вызывали:
        
        $ python3 -m pip --version
        Эта команда означает "python3, запусти модуль (-m) с именем pip как программу с параметром --version". Если вы в дальнейшем увидите в документации к pip команды, вроде pip help, то смело вызывайте python3 -m pip help — результат будет нужный!
        
        Установка первого пакета
        Установим же первый пакет! Пусть это будет пакет cowsay, но устанавливать мы его будем сразу в пользовательское окружение. Причин для установки туда есть несколько:
        
        мы не помешаем своими пакетами другим пользователям системы,
        нам не потребуются права администратора (у пользователя их может и не быть),
        мы не поломаем саму операционную систему случайной установкой более свежего пакета, чем тот, который требуется системе для нормальной работы (особенно это важно в Linux, где многие системные задачи решаются с помощью Python).
        Итак, установка cowsay:
        
        
        Во-первых, мы видим, что пакет установился и стал доступен интерпретатору. Во-вторых, пакет — забавный :)
        
        Флаг –-user команды pip install сообщает pip, что мы хотим установить пакет в глобальное окружение текущего пользователя. Если этот флаг не указать, то pip установит пакет в общесистемное окружение. Старайтесь не делать так!
        
        pip, точки входа и PATH
        Установленный пакет cowsay, как мы видели выше, может быть использован из кода. Но этот пакет имеет ещё и так называемую точку входа (или entry point).
        
        Точки входа, это готовые к исполнению программы, содержащиеся в пакете. Если у пакета есть таковые, то pip создаст для каждой специальный исполняемый скрипт, который позволит удобно запускать программу из командной оболочки. Но нужно помнить, что путь до директории, в которую pip помещает такие скрипты (на Linux это ~/.local/bin) нужно добавить в PATH! Если путь прописан правильно, то скрипт для cowsay должен работать так:
        
        
        Точка входа, это всегда Python-модуль, пригодный для запуска в роли программы (такие программы называют ещё исполняемыми файлами, позже мы рассмотрим, как такие делать). Создаваемые pip'ом скрипты внутри вызывают python3 -m имя_модуля, поэтому установленный нами cowsay можно запускать точно также:
        
        
        Всегда свежий pip!
        Как вы могли уже догадаться, сам pip, это тоже точка входа одноимённого пакета pip, поэтому мы его запускаем командой python3 -m pip. А ещё pip может устанавливать и, что более важно, обновлять! Вы можете установить свежий pip в пользовательское окружение (именно туда, чтобы не сломать системный pip) с помощью такой команды:
        
        $ python3 -m pip install --user --upgrade pip
        Флаг --upgrade позволит обновить уже установленный пакет, если в индексе найдётся более новая версия.
        
        Дополнительные материалы
        pip - The Python Package Installer`,
      tests: {},
      tasks: {},
    },
  ],
  pip_и_альтернативные_источники_пакетов: [
    {
      theory: `
        На прошлом уроке мы установили пакет cowsay. Если не уточнить иное специально, pip устанавливает пакеты из основного индекса — PyPI. Оттуда был взят и пакет cowsay.

        В большинстве случаев PyPI — это именно тот источник пакетов, который нам нужен. Но бывают случаи, когда пакет находится в альтернативном индексе — например, внутрикорпоративном — или же вообще ещё не опубликован ни в одном индексе, а просто загружен на GitHub. Pip умеет работать и с альтернативными индексами и с репозиториями, содержащими исходный код пакетов. Рассмотрим оба варианта.
        
        Альтернативные индексы пакетов
        Если вызывать команду pip install с опцией --index-url <url>, то pip будет искать пакет и все его зависимости в индексе по указанному url. Давайте попробуем установить пакет из специального тренировочного индекса Test PyPI:
        
        
        Заметьте, что url индекса указан в виде что-то-там/simple — именно так по соглашению должны именоваться индексы.
        
        Test PyPI содержит плюс-минус все пакеты, которые есть в основном PyPI, но обычно держателям локальных индексов не хочется держать у себя копии всех версий всех пакетов — хочется хранить только свои пакеты, а все внешние зависимости получать из другого индекса (обычно это уже общий PyPI). У pip и для такого случая есть опция! Всего-то и нужно в дополнение к --index-url указать --extra-index-url <url>. В такой конфигурации pip ищет каждый пакет в первом индексе, а если не найдёт, то обращается ко второму, дополнительному индексу. Команда целиком может выглядеть так:
        
        $ python3 -m pip install --user --index-url https://test.pypi.org/simple --extra-index-url https://pypi.org/simple dogesay
        Установка пакетов из репозиториев на GitHub
        Иногда пакет не хочется выкладывать на PyPI, скажем, по причине того, что пакет ещё совсем "сырой", но при этом нужно проверить, как пакет работает и устанавливается ли вообще. В подобных случаях пакеты устанавливают прямо из git-репозиториев. Давайте установим с помощью pip наш учебный hexlet-boilerplates/python-package:
        
        
        Внимание: этот пакет установится, только если у вас pip будет версии 20 и выше. Если вы увидите ошибку при установке пакета, попробуйте обновить сам pip (python3 -m pip install --user --upgrade pip).
        
        Здесь вместо имени пакета указывается тот же url, который вы использовали бы при клонировании репозитория, но дополненный приставкой git+. Эта приставка подсказывает pip, что по url расположен Git-репозиторий — не обязательно размещённый на GitHub.
        
        Во время установки пакета, pip вызывает git clone для клонирования репозитория во временную директорию. Если репозиторий закрытый, то у вас будут запрошены имя пользователя и пароль для доступа к репозиторию — это работает и с приватными репозиториями GitHub!
        
        Управлять установкой пакетов из систем контроля версий (да, систем — pip поддерживает не только Git!) можно очень гибко, например, указывать ветки, теги или хэши коммитов, по которым расположена желаемая версия пакета. Подробнее можно почитать тут.
        
        Мы рассмотрели далеко не все виды источников пакетов, да и саму команду pip install рассмотрели очень поверхностно. По возможности рекомендуем изучить эту и прочие команды pip самостоятельно, ведь pip — один из ключевых инструментов разработчика на Python!
        
        Дополнительные материалы
        pip - The Python Package Installer
        Test PyPI
        Python package example (boilerplate)`,
      tests: {},
      tasks: {},
    },
  ],
  Виртуальные_окружения: [
    {
      theory: `
        Как уже говорилось ранее, pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет оный сначала в пользовательском окружении, затем в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python программ. Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами: разные проекты могут иметь разные наборы зависимостей. Ещё более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные её версии — конфликт версий.

        Очевидно, что как минимум разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных "песочницах". Такой механизм существует и называется виртуальные окружения.
        
        Устройство виртуальных окружений
        Каждое виртуальное окружение представляет собой директорию, содержимое которой структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:
        
        $ tree env
        env
        ├── bin
        │   ├── activate
        │   …
        │   ├── pip
        │   …
        │   └── python3 -> …/python3
        ├── lib
        │   └── python3.6
        │       └── site-packages
        │           ├── pip
        │           │   ├── …
        │           …
        │           └── setuptools-40.6.2.dist-info
        │               ├── …
        …
        В директории виртуального окружения находится директория bin/ внутри которой находится копия (или символическая ссылка на оригинал) интерпретатора под именем python3, а рядом с ней находится копия исполняемого файла pip. В соседней директории по пути lib/python3.6/site-packages находятся библиотеки, уже установленные в окружение: только что созданное окружение как правило имеет установленный пакет pip (а исполняемый файл bin/pip — его точка входа), а также пакет setuptools — эти два пакета составляют "необходимый минимум" для разработки проекта на Python.
        
        При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из директории bin. Дело в том, что интерпретатор Python, когда находится в окружении, знает, что по относительному (к директории bin) пути ../lib/python3.6 находятся все доступные пакеты. И копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая желанная изоляция!
        
        Создание виртуального окружения
        Конечно же, вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.
        
        В macOS и Windows этот модуль, как и pip, входит в поставку Python. На Ubuntu же его нужно установить отдельно командой
        
        $ sudo apt install python3-venv
        Проверим, что модуль установлен и пригоден к использованию:
        
        
        Создаётся окружение командой python3 -m venv имя_окружения. Давайте создадим одно и установим в это окружение пакет cowsay:
        
        
        Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay, а также сам пакет становится доступен интерпретатору, но только тому, что запущен из окружения.
        
        В принципе в таком виде виртуальное окружение уже можно использовать полноценно. Но вводить команды с префиксом first_env/bin/ не очень-то хочется, и есть способ упростить вызов команд, доступных в окружении — активация.
        
        Активация окружения
        При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Этот сценарий нужно выполнить:
        
        на macOS и Ubuntu вызвать команду
        $ source first_venv/bin/activate
        на Windows вызвать команду
        C:\> first_venv\Scripts\activate.bat
        Заметьте, в Windows поддиректория с исполняемыми файлами называется не bin, а Scripts!
        
        На Ubuntu активация выглядит следующим образом:
        
        
        Вы можете заметить, что после активации отпала необходимость указывать путь до вызываемого исполняемого файла — cowsay и python в аскинеме вызываются без префикса, но это всё те же команды из окружения!
        
        Ещё вы могли заметить, что приглашение оболочки изменилось: в нём стало отображаться имя окружения. Этот трюк работает на macOS и Ubuntu и позволяет всегда видеть, что мы находимся в виртуальном окружении.
        
        Деактивация же окружения делается командой deactivate, которая становится доступна после активации.
        
        Активирование и деактивация окружения влияют только на текущую сессию (заметны только в этом конкретном терминале). Что позволяет иметь несколько окружений и активировать их одновременно в разных окнах терминала.
        
        Итого
        Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.
        
        Ссылки
        "venv — Creation of virtual environments", официальная документация по модулю venv.
        pipx, установщик Python-программ, размещающий каждую программу в её собственном виртуальном окружении, но скрывающий от конечного пользователя такие "излишние тонкости": пользователь получает сразу доступную оболочке команду — отличный способ устанавливать для постоянного использования штуки, вроде cowsay и dogesay.
        Дополнительные материалы
        venv - Creation of virtual environments`,
      tests: {},
      tasks: {},
    },
  ],
  Cкрипты: [
    {
      theory: `
        Любая программа должна быть когда-нибудь запущена, иначе зачем её вообще писать? В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код, всю работу делает интерпретатор, которому достаточно подать на вход скрипт (англ. script) — так часто называют программы на интерпретируемых языках, представляющие из себя простые последовательности команд, которые компьютеру нужно выполнить. Часто языки, которые максимально упрощают написание скриптов (как говорят, "скриптование") и их запуск, называют "скриптовыми языками" или же "языками для написания сценариев" (слово "script" на русский переводится как "сценарий").

        Скрипты на Python
        Python отлично подходит на роль скриптового языка: последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто — мы просто пишем команды одну за другой в файл:
        
        # file <script.py>
        print('Hello, world!')
        print('This is a python-script!')
        а затем просто вызываем интерпретатор с полученным файлом на входе:
        
        $ python3 script.py
        Hello, world!
        This is a python-script!
        Эта простота использования вместе с большим количеством полезных модулей и функций, входящих в поставку Python, делают последний хорошим инструментом для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием!
        
        Скрипты и shebang
        В unix-подобных операционных системах (macOS, Linux, BSD etc) командные оболочки умеют запускать скрипты на любых языках, в т.ч. и на Python, если эти скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария. Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang, от названий первых двух символов такой строчки: # называется "sharp", а ! - "bang!".
        
        Типичный shebang выглядит так:
        
        #!/usr/bin/python3
        где после символов #! идёт путь до интерпретатора. Командная оболочка при запуске скрипта, содержащего shebang, читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно будет не указывать:
        
        $ cat script.py
        #!/usr/bin/python3
        print('Hello!')
        
        $ chmod +x script.py
        
        $ ./script.py
        Hello!
        Shebang и разные версии Python
        shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении — а в работе вы практически всегда будете их использовать — путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях! Как же сделать так, чтобы скрипт запускался всегда с нужной версией Python? Есть способ добиться такой универсальности: нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.
        
        Эта программа умеет находить и запускать программы с учётом переменных окружения и, т.к. при активации виртуального окружения модифицируется переменная $PATH, то env будет запускать именно ту версию интерпретатора, которая нам нужна (она просто найдётся раньше, т.к. путь до исполняемых файлов окружения добавляется в начало $PATH).
        
        Итак, представляем правильный способ указывать shebang в проектах на python! Встречайте:
        
        #!/usr/bin/env python3
        print('Hello!')
        Путь до env указан конкретный потому, что эта программа практически всегда располагается именно там и не встречается в нескольких версиях :) А запомнить это правило написания shebang очень легко — "вызываем python3 с учётом окружения" ("env", это сокращение от "environment"/"окружение").
        
        Ссылки
        shebang (Unix)
        Урок "Выполнение программ" (из курса "Основы командной строки")`,
      tests: {},
      tasks: {},
    },
  ],
  Запускаемые_модули_и_пакеты: [
    {
      theory: `
        Как писать скрипты, мы уже узнали. Теперь представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нём появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать, скажем, функцию из этого модуля в другом модуле. Значит, нужно импортировать!

        Импортирование скриптов
        Давайте же смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:
        
        # file <first_script.py>
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        greet('Bob')
        greet('Ann')
        А так — новый скрипт, в котором мы хотим переиспользовать функцию greet из первого модуля (скрипты — тоже модули):
        
        # file <second_script.py>
        
        from first_script import greet
        
        greet('Thomas')
        Запустим первый скрипт, а затем — второй (оба файла расположены в текущей директории):
        
        $ python3 first_script.py
        Hello, Bob!
        Hello, Ann!
        $ python3 second_script.py
        Hello, Bob!
        Hello, Ann!
        Hello, Thomas!
        Что мы видим — при выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию! Такова цена за простоту написания скриптов! Поскольку файл первого скрипта содержит не только определения, но и непосредственные действия (statements), то при загрузке файла (которая происходит при импорте модуля) эти действия будут выполнены. Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы или того хуже — запускаются межконтинентальные ракеты!
        
        Выходит, нам нужно как-то различать ситуации когда
        
        модуль выполняется как скрипт (выполняем побочные действия),
        модуль или его содержимое импортируются (не выполняем побочные действия).
        Для этого нам понадобится немного магии!
        
        Специальная переменная __name__
        Машинерия импортирования при загрузке модуля в первый раз (первый для текущего запуска интерпретатора) добавляет в этот модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная __name__.
        
        Не стоит пугаться такого странного имени аж с четыремя символами подчёркивания: такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный питонист помнит наизусть пару десятков таких переменных, а ещё про эти переменные любят спрашивать на собеседованиях.
        
        Что же хранит переменная __name__ в каждом конкретном случае? В этом и весь секрет!
        
        Если происходит обычный импорт, то эта переменная содержит полное имя модуля (полностью квалифицированное).
        Если же происходит запуск в качестве скрипта, то переменная получает специальное значение — строку '__main__'.
        Глядя на значение этой переменной, можем отличать "запуск" от импортирования.
        
        Слово "main" используется во многих языках для именования функции, которая вызывается автоматически при старте программы, потому и в Python это слово используется в похожем смысле
        
        Давайте вернёмся к нашему примеру и перепишем first_script.py с применением этого нового знания:
        
        # file <first_script.py>
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        if __name__ == '__main__':
            greet('Bob')
            greet('Ann')
        Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль. Это победа!
        
        Функция main
        Наш first_script.py уже достаточно хорош. Но мы можем его ещё чуть-чуть улучшить.
        
        В теле условия if __name__… у нас перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много. И, как вы бы догадались, может статься, что мы захотим переиспользовать и этот кусок кода! Скажу даже больше, такое происходит нередко. Поэтому существует соглашение: в теле условия if __name__… делают всего один вызов функции без аргументов main, которую объявляют выше в этом же модуле (само условие принято располагать в самом конце модуля скрипта).
        
        С учётом всех описанных рекомендаций финальная версия скрипта first_script.py будет выглядеть так:
        
        #!/usr/bin/env python3
        
        def greet(who):
            print('Hello, {}!'.format(who))
        
        def main():
            greet('Bob')
            greet('Ann')
        
        if __name__ == '__main__':
            main()
        Такой скрипт можно
        
        запускать непосредственно;
        запускать из других скриптов, вызывая функцию main;
        использовать как библиотеку.
        Запускаемые пакеты
        Рассмотрим немного экзотический, но всё же встречающийся случай — запуск пакета. Могло бы показаться, что раз при загрузке пакета всегда загружается модуль __init__.py, то и функцию main, и условие нужно располагать в нём. Но авторы по ряду причин решили реализовать запуск пакетов несколько иначе: при загрузке пакета перед запуском ищется модуль __main__.py и выполняется как скрипт. Здесь мы не будем углубляться в причины, побудившие авторов языка сделать именно так, и просто запомним, что исполняемые пакеты всегда содержат скрипт __main__.py.
        
        Когда же может понадобится запуск пакета? Сходу можно представить такой пример. Пусть мы имели один небольшой скрипт. Со временем кода в нём становилось всё больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать. Мы решили превратить один модуль в пакет, содержащий несколько. Но как такой пакет в дальнейшем запускать? Вот для этого мы и можем использовать модуль __main__.py!
        
        Задание
        Создайте модуль module.py следующего вида:
        print("__name__ == '{}'".format(__name__))
        В REPL импортируйте модуль: интерпретатор запускайте, находясь в директории, содержащей модуль, а в приглашении выполните import module
        Посмотрите, что выведется на экран.
        Запустите модуль на исполнение (вызовите python3 module.py из директории, в которой вы создали модуль).
        Посмотрите, что выводится на экран на этот раз.
        Ссылки
        Полный список того, что добавляет в модуль машинерия импортирования
        Имя 'main' и его значение
        Дополнительные материалы
        shebang (Unix)`,
      tests: {},
      tasks: {},
    },
  ],
  Доступный_инструментарий_для_работы_с_Python_проектами: [
    {
      theory: `
    О важности выбора инструментария
Сам по себе язык программирования мало интересен, если для него нет подходящего интерпретатора или компилятора. Но программы нужно не только запускать — их нужно доставлять до пользователя. Да и редкая программа бывает сразу готова, поэтому единожды доставленную программу нужно обновлять. А ещё её нужно продолжать разрабатывать — иногда в течение нескольких лет. Поэтому периодически возникают ситуации, когда нужно обновить какие-то сторонние библиотеки, а иногда и сам компилятор или интерпретатор. Для решения вышеперечисленных задач применительно к Python в разное время появились и развились различные инструменты. О некоторых из них ниже пойдёт речь.

Большинство инструментов имеет хорошую документацию, поэтому в рамках курса не будет дублироваться эта информация. Цель урока — дать общее представление, а местами предоставить и право выбора, какой инструмент выбрать среди доступных.

Но для начала познакомимся с новой концепцией — lock-файлами.

lock-файлы
Обычно, при разработке автор некоторой библиотеки или программы так или иначе указывает версии сторонних пакетов, которые требуются для работы его творения. Обычно версия не закрепляется жёстко, вместо этого указывается диапазон версий, в пределах которого можно ожидать, что совместимость разных частей кода не нарушится. Именно для этого часто используется семантическое версионирование.

Однако случается, что либо диапазон версий бывает указан слишком широкий, либо семантическое версионирование оказывается применено неверно, или же просто в какой-то версии некоего пакета оказывается ошибка. Возникает ситуация, когда проект работает как нужно не на любом из сочетаний разных версий пакетов, а на некотором вполне конкретном.

lock-файл как раз и предназначен для того, чтобы в дополнение к перечню пакетов с "нечёткими" версиями, таки зафиксировать список конкретных версий, которые в данный момент для проекта подходят! В том или ином виде lock-files сейчас используются большинством современных пакетных менеджеров для разных языков программирования.

pyenv, средство управления разными версиями интерпретатора.
Даже на этапе обучения важно иметь актуальную версию интерпретатора. И Python, будучи языком, который давно начали использовать для нужд автоматизации, часто бывает доступен в каталогах пакетов различных ОС. Однако пакеты как правило содержат только CPython (а ведь есть и другие реализации интерпретаторов Python, очень полезные в различных ситуациях), и далеко не всегда "свежий".

Авторы библиотек часто вынуждены поддерживать несколько версий Python и проверять, что новые изменения, вносимые в код, не сказываются на работоспособности оного при работе с разными версиями Python.

Т.о. на одной машине может быть установлено несколько разных реализаций Python и каждая — в более чем одном варианте. А управлять всем этим "серпентарием" призван pyenv. Как бы вы не использовали Python, вам стоит научиться использовать этот инструмент.

pipenv, "инструментарий для людей"
Да, авторы pipenv так про своё детище и пишут. Что же это за штука? pipenv берёт на себя

управление пакетами, т.е. заменяет pip (но использует "под капотом");
создание виртуальных окружений (c "под капотом" venv);
работу с зависимостями, контроль за версионированием и обновлением оных, построение графа зависимостей;
воспроизводимость сборки (через использование тех самых lock-файлов).
pipenv — инструмент мощный, но требующий умения использовать distutils/setuptools для описания процесса сборки пакета с проектом. Новичкам может быть сложно освоить именно этот аспект использования в остальном достаточно удобной программы.

По ссылке выше вы найдёте сайт с подробнейшей документацией, советую хотя бы заглянуть туда.

poetry, ещё один человечный инструмент разработки
В наших курсах и проектах я рекомендую использовать именно poetry. Также именно с помощью poetry оформлен наш python package boilerplate. Что же это за инструмент?

poetry, это сравнительно молодой проект, упрощающий разработку на Python. В целом он решает все те же проблемы (и тоже использует lock-файлы), что решает и pipenv, но в отличие от последнего, берёт на себя сборку пакетов. Более того, вместе с poetry вам не нужно глубоко погружаться в изучение distutils/setuptools — оные вообще не используются при описании poetry-пакета!

Документация у poetry компактная, но очень понятная. Описана и рекомендуемая структура директорий в типичном проекте и использование альтернативных индексов и многие другие аспекты — и всё это снабжено примерами! Проходите по ссылке выше и знакомьтесь.

Важно: напоминаю, я буду предполагать в дальнейших курсах и проектах использование именно poetry!

ipython, REPL, которого мы заслужили!
Python REPL довольно удобен, а главное — всегда доступен. Но использовать его для ввода большого количества кода неудобно (даже многострочный код не поредактируешь нормально!). Однако REPL в Python сделан модульным и существует несколько "улучшенных версий", наиболее популярная из которых — IPython.

IPython имеет

подсветку синтаксиса,
удобное автодополнение модулей для импортирования и определений в модулях,
подсказки по аргументам функций и отображение документации,
и многое-многое другое!
Большинство разработчиков, занимающихся анализом данных, проводят в IPython большую часть своего рабочего времени — настолько это мощная и полезная оболочка!

Всего не охватить...
Вокруг базового инструментария Python за десятилетия существования языка было создано огромное количество полезностей. И благодаря тому, что в Python-мире правила хорошего тона предполагают тщательное документирование кода и сам синтаксис к этому располагает (всё те же docstrings), практически любой инструмент можно освоить самостоятельно — стоит лишь проявить любопытство! Всегда можно открыть сайт PyPI и пройтись по списку тем (topics), чтобы найти интересные проекты, способные сильно упростить жизнь и просто сделать процесс разработки и изучения более приятным!`,
      tests: {},
      tasks: {},
    },
  ],
};
